专周 课程设计说明文档

数据结构

| 作者姓名： | 欧阳家胜               |
| ---------- | ---------------------- |
| 学   号：  | 3221311329             |
| 指导教师： | 杨海燕                 |
| 学院专业： | 计算机科学与技术2203班 |

# ***\*1. A\*******\*类必做\****

## ***\*1\*******\*.1\**** ***\*排序题\****

###  ***\*1.1.1\**** ***\*题目的解题思路\****

 

在程序中分别使用希尔排序、快速排序、堆排序（大根堆和小根堆）、归并排序和计数排序，对一个无序整数序列A进行升序排列。并且一次次输出排序过程，

 

### ***\*1.1.2\**** ***\*题目的关键代码\****	

\#define MAX_VALUE 10000 // 假设计数排序的最大值

​	int A[]={6, 12, 458, 5, 4, 28, 19, 1230, 9, 47};

​	int ALen=sizeof(A)/sizeof(A[0]); 

​	 int n = sizeof(A) / sizeof(A[0]);\

//序列：{6, 12, 458, 5, 4, 28, 19, 1230, 9, 47}

//希尔排序 

void ShellInsert(int A[], int step) {

  int i, j, temp;

  int ALen=sizeof(A)/sizeof(A[0]); 

  for (i = step; i < ALen; i++) { // 遍历数组，从第step个元素开始（根据步长来确定）

​    temp = A[i]; // 保存当前要插入的元素,空出位置 

​    j = i - step; // 计算插入位置

​		for ( ;A[j] > temp;j = j - step) { // 找到要插入的位置

​      A[j + step] = A[j];  //5<-0

​       // 向前比较下一个元素

​    }

​    A[j + step] = temp; // j=j-5  ;0<-5

  }

}

void ShellSort(int A[]){

​	int k,i;

​	int AStep[]={5,3,1};

​	for(k=0;k<(sizeof(AStep)/sizeof(AStep[0]));k++){

​		ShellInsert(A,AStep[k]);

​		//输出

​		printf("步长为%d:的排序完成之后的结果\n",AStep[k]); 

​		for(i=0;i<sizeof(A)/sizeof(A[0]);i++){

​			printf("%d-",A[i]);

​		}

​		printf("\n\n");

​	}

}

//快速排序 

void QSwap(int *a,int *b){		//堆排序、 快速排序均调用 QSwap 

​	int temp=*a;				

​	*a=*b;

​	*b=temp;

}

int Qpartition(int arr[],int low,int high){

​	int pivot=arr[high];

​	int i=(low-1);

​	for(int j=low;j<=high-1;j++){

​		if(arr[j]<pivot){

​			i++;

​			QSwap(&arr[i],&arr[j]);

​		}

​	}

​	QSwap(&arr[i+1],&arr[high]);

​	return (i+1);

}

void QSort(int arr[],int low,int high){

​	if(low<high){

​		int pi=Qpartition(arr,low,high);

​		QSort(arr,low,pi-1);	//对低子表递归排序 

​		QSort(arr,pi+1,high);	//高子表递归排序 

​	}

}

//堆排序

void Dui(int arr[], int n, int i) {

  int largest = i;

  int left = 2 * i + 1;

  int right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest]) {

​    largest = left;

  }

  if (right < n && arr[right] > arr[largest]) {

​    largest = right;

  }

  if (largest != i) {

​    QSwap(&arr[i], &arr[largest]);

​    Dui(arr, n, largest);

  }

}

void DuiSort(int arr[], int n) {

  //构建堆 从最后一个非叶子节点开始

  for (int i = n / 2 - 1; i >= 0; i--) {

​    Dui(arr, n, i);

  }

  //逐个提取元素并重建堆 

  for (int i = n - 1; i > 0; i--) {

​    QSwap(&arr[0], &arr[i]); //将当前最大值移动至数组末尾 

​    Dui(arr, i, 0);      //重新调整堆 

  }

}

//归并排序

void merge(int arr[], int left, int middle, int right) {

  int i, j, k;

  int n1 = middle - left + 1;

  int n2 = right - middle;

 

  int Left[n1], Right[n2];

 

  for (i = 0; i < n1; i++)

​    Left[i] = arr[left + i];

  for (j = 0; j < n2; j++)

​    Right[j] = arr[middle + 1 + j];

  i = 0;

  j = 0;

  k = left;

  while (i < n1 && j < n2) {

​    if (Left[i] <= Right[j]) {

​      arr[k] = Left[i];

​      i++;

​    } else {

​      arr[k] = Right[j];

​      j++;

​    }

​    k++;

  }

 

  while (i < n1) {

​    arr[k] = Left[i];

​    i++;

​    k++;

  }

  while (j < n2) {

​    arr[k] = Right[j];

​    j++;

​    k++;

  }

}

void mergeSort(int arr[], int left, int right) {

  if (left < right) {

​    int middle = left + (right - left) / 2;

​    mergeSort(arr, left, middle);

​    mergeSort(arr, middle + 1, right);

​    merge(arr, left, middle, right);

  }

} 

//计数排序

void countingSort(int arr[], int n) {

  int output[n];

  int count[MAX_VALUE + 1];

  for (int i = 0; i <= MAX_VALUE; ++i) {

​    count[i] = 0;

  }

  // 统计数组中每个元素的出现次数

  for (int i = 0; i < n; ++i) {

​    ++count[arr[i]];

  }

  // 将计数信息转换为元素的实际位置

  for (int i = 1; i <= MAX_VALUE; ++i) {

​    count[i] += count[i - 1];

  }

  // 根据计数信息将元素放置到输出数组的正确位置上

  for (int i = n - 1; i >= 0; --i) {

​    output[count[arr[i]] - 1] = arr[i];

​    --count[arr[i]];

  }

  // 将排序好的数组拷贝回原数组

  for (int i = 0; i < n; ++i) {

​    arr[i] = output[i];

  }

}

### ***\*1.1.3\**** ***\*流程图（如果有）\****

### ***\*1.1.4\**** ***\*程序的运行截图\****

希尔排序每次调换之后的		

 

希尔排序是插入排序的改进版本，通过优先比较距离较远的元素，可以使得元素更快地回到合适的位置，从而减少了数据移动的次数。然而，它的时间复杂度和空间复杂度分析相对复杂。

 

时间复杂度：O(n^2)，这种情况下增量序列最终会变成 1，退化成普通的插入排序。平均情况下的时间复杂度难以精确计算，一般介于 O(n log^2 n) 和 O(n^1.5) 之间，根据不同的增量序列选择可能有所不同。

空间复杂度： O(1)希尔排序是原地排序算法，不需要额外的空间。	

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps2.jpg) 

 

##  

 

 

 

 

快速排序：

快速排序用了分块，递归的思维，首先取一个随机数pivot标记，比pivot大的放到右边，比pivot小的放左边，将数组分成上部分和下部分，然后分别对上部分和下部分递归重新选pivot进行排序。

 

时间复杂度：取决于基准元素的选择以及数组的划分情况。在最好和平均情况下，快速排序的时间复杂度为O(n log n)。这种情况下，每次划分都能将数组均匀地分成两部分。但在最坏情况下，即当每次划分都导致一个子数组为空（或只有一个元素）时，时间复杂度会达到O(n^2)。

 

空间复杂度：快速排序是一种原地排序算法，它不需要额外的存储空间，快速排序的空间复杂度为O(log n)到O(n)，取决于递归调用栈的深度。在最好和平均情况下，空间复杂度为O(log n)。

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps3.jpg) 

堆排序：

堆排序是一种基于完全二叉堆（Heap）数据结构的排序算法，它分为两个主要阶段：构建堆和堆的调整。

 

构建堆：将待排序的数组视为一个完全二叉树，并且根据排序要求构建出一个堆结构。堆的构建从最后一个非叶子节点开始，自底向上进行堆调整操作。

堆的调整：不断地将堆顶元素（即最大值或最小值）与堆中最后一个元素交换，然后缩小堆的范围，重新调整堆结构，保证剩余部分仍然是一个合法的堆。

 

时间复杂度：堆排序的平均时间复杂度为 O(nlogn)，其中 n 是数组的大小。这个时间复杂度来自于构建堆和调整堆两个主要阶段的复杂度。

 

空间复杂度：堆排序的空间复杂度为 O(1)，是一个原地排序算法，只需要常量级的额外空间用于辅助交换操作。

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps4.jpg) 

 

归并排序：它的主要思路是将待排序的数组递归地分成较小的数组，然后对这些较小的数组进行排序，最后将排好序的子数组合并起来，直到整个数组排序完成。

1、分割：将数组递归地分成两个子数组，直到每个子数组只有一个元素。

2、合并：将两个有序的子数组合并成一个更大的有序数组。

 

归并排序的时间复杂度是 O(n log n)，其中 n 是待排序数组的长度。它的空间复杂度为 O(n)，因为需要额外的空间来存储临时数组和递归调用的栈空间。

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps5.jpg) 

 

计数排序：适用于非负整数的排序。它通过统计每个元素出现的次数，然后根据计数信息将元素放置到输出数组的正确位置上，最终完成排序。

\1. 统计数组中每个元素的出现次数。

\2. 将计数信息转换为元素的实际位置。

\3. 将排序好的数组拷贝回原数组，完成排序。

 

时间复杂度：

时间复杂度为 O(n + k)，其中 n 是待排序元素个数，k 是非负整数的范围。这是因为计数排序的关键操作是统计和遍历计数数组。

空间复杂度：

计数排序的空间复杂度主要取决于计数数组的大小，为 O(k)。

 

在进行计数排序时，需要注意待排序数组的最大值范围，以便正确分配计数数组的大小。

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps6.jpg) 

## ***\*1\*******\*.2\**** ***\*散列表\****

线性探测法：

本题我是事先准备好9个测试样例，然后用结构体数组等等做出10个空位，多余的一个用来线性探测的兼容；

如下是散列表线性探测法的运行截图

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps7.jpg) 

以下是平方探测法的运行截图

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps8.jpg) 

以下是关键函数

\#include <stdio.h>

\#include <string.h>

\#include <stdlib.h>

\#define TABLE_SIZE 10

double searchCount = 0; // 记录查找次数

double bugCount = 0;   // 冲突次数

typedef struct {

  char phoneNumber[12];

  char username[20];

  char address[50];

} Record;

 

typedef struct {

  Record *data;

  int size;

} HashTable;

 

// 哈希函数，根据电话号码的最后一位计算哈希值

int hashFunc(char *phoneNumber) {

  int lastDigit = phoneNumber[strlen(phoneNumber) - 1] - '0';

  return lastDigit;

}

 

// 创建哈希表（线性探测法）

HashTable *Xianxin_creat() {

  HashTable *hashTable = (HashTable *)malloc(sizeof(HashTable));

  hashTable->data = (Record *)calloc(TABLE_SIZE, sizeof(Record));

  hashTable->size = TABLE_SIZE;

  return hashTable;

}

 

// 插入记录（线性探测法）

void Xianxin_insert(HashTable *hashTable, char *phoneNumber, char *username, char *address) {

  int index = hashFunc(phoneNumber);

  searchCount++; // 每次插入记录时，查找次数加1

  while (hashTable->data[index].phoneNumber[0] != '\0') {

​    index = (index + 1) % hashTable->size;

​    bugCount++; // 冲突次数加1

  }

  strcpy(hashTable->data[index].phoneNumber, phoneNumber);

  strcpy(hashTable->data[index].username, username);

  strcpy(hashTable->data[index].address, address);

}

 

// 创建哈希表（平方探测法）

HashTable *Pinfang_creat() {

  HashTable *hashTable = (HashTable *)malloc(sizeof(HashTable));

  hashTable->data = (Record *)calloc(TABLE_SIZE, sizeof(Record));

  hashTable->size = TABLE_SIZE;

  return hashTable;

}

 

// 插入记录（平方探测法）

void Pinfang_insert(HashTable *hashTable, char *phoneNumber, char *username, char *address) {

  int index = hashFunc(phoneNumber);

  int i = 0;

  searchCount++; // 每次插入记录时，查找次数加1

  while (hashTable->data[(index + i * i) % hashTable->size].phoneNumber[0] != '\0') {

​    i++;

​    bugCount++; // 冲突次数加1

  }

  strcpy(hashTable->data[(index + i * i) % hashTable->size].phoneNumber, phoneNumber);

  strcpy(hashTable->data[(index + i * i) % hashTable->size].username, username);

  strcpy(hashTable->data[(index + i * i) % hashTable->size].address, address);

}

 

// 创建哈希表（拉链法）

HashTable *Lalian_creat() {

  HashTable *hashTable = (HashTable *)malloc(sizeof(HashTable));

  hashTable->data = (Record *)calloc(TABLE_SIZE, sizeof(Record));

  hashTable->size = TABLE_SIZE;

  return hashTable;

}

 

// 插入记录（拉链法）

void Lalian_insert(HashTable *hashTable, char *phoneNumber, char *username, char *address) {

  int index = hashFunc(phoneNumber);

  Record *p = &(hashTable->data[index]); // 找到对应的链表

  while (p->phoneNumber[0] != '\0') {

​    p++;

​    bugCount++; // 冲突次数加1

  }

  strcpy(p->phoneNumber, phoneNumber);

  strcpy(p->username, username);

  strcpy(p->address, address);

}

 

// 打印哈希表

void printHashTable(HashTable *hashTable) {

  for (int i = 0; i < hashTable->size; i++) {

​    if (hashTable->data[i].phoneNumber[0] != '\0') {

​      printf("槽位 %d: %s %s %s\n", i, hashTable->data[i].phoneNumber, hashTable->data[i].username, hashTable->data[i].address);

​    } else {

​      printf("槽位 %d: 空\n", i);

​    }

  }

}

 

int main() {

  int method;

  printf("请选择哈希方法：\n");

  printf("1. 线性探测法\n");

  printf("2. 平方探测法\n");

  printf("3. 拉链法\n");

  scanf("%d", &method);

 

  HashTable *hashTable;

  switch (method) {

​    case 1:

​      hashTable = Xianxin_creat();

​      Xianxin_insert(hashTable, "123-456-7890", "鸣人", "北京市");

​      Xianxin_insert(hashTable, "234-567-8901", "佐助", "上海市");

​      Xianxin_insert(hashTable, "345-678-9012", "小樱", "广州市");

​      Xianxin_insert(hashTable, "456-789-0122", "卡卡西", "深圳市");

​      Xianxin_insert(hashTable, "567-890-1233", "雏田", "天津市");

​      Xianxin_insert(hashTable, "678-901-2345", "大蛇丸", "成都市");

​      Xianxin_insert(hashTable, "789-012-3456", "奈良", "杭州市");

​      Xianxin_insert(hashTable, "890-123-4567", "山中井野", "武汉市");

​      Xianxin_insert(hashTable, "901-234-5678", "沙罗", "南京市");

​      break;

​    case 2:

​      hashTable = Pinfang_creat();

​      Pinfang_insert(hashTable, "123-456-7890", "鸣人", "北京市");

​      Pinfang_insert(hashTable, "234-567-8901", "佐助", "上海市");

​      Pinfang_insert(hashTable, "345-678-9015", "小樱", "广州市");

​      Pinfang_insert(hashTable, "456-789-0122", "卡卡西", "深圳市");

​      Pinfang_insert(hashTable, "567-890-1233", "雏田", "天津市");

​      Pinfang_insert(hashTable, "678-901-2345", "大蛇丸", "成都市");

​      Pinfang_insert(hashTable, "789-012-3456", "奈良", "杭州市");

​      Pinfang_insert(hashTable, "890-123-4567", "山中井野", "武汉市");

​      Pinfang_insert(hashTable, "901-234-5678", "沙罗", "南京市");

​      break;

​    case 3:

​      hashTable = Lalian_creat();

​      Lalian_insert(hashTable, "123-456-7898", "鸣人", "北京市");

​      Lalian_insert(hashTable, "234-567-8901", "佐助", "上海市");

​      Lalian_insert(hashTable, "345-678-9012", "小樱", "广州市");

​      Lalian_insert(hashTable, "456-789-0122", "卡卡西", "深圳市");

​      Lalian_insert(hashTable, "567-890-1235", "雏田", "天津市");

​      Lalian_insert(hashTable, "678-901-2345", "大蛇丸", "成都市");

​      Lalian_insert(hashTable, "789-012-3456", "奈良", "杭州市");

​      Lalian_insert(hashTable, "890-123-4567", "山中井野", "武汉市");

​      Lalian_insert(hashTable, "901-234-5678", "沙罗", "南京市");

​      break;

​    default:

​      printf("无效选择。\n");

​      return 1;

  }

  printHashTable(hashTable);

  printf("冲突率为百分之%.0lf\n", bugCount / searchCount * 100);

 

  free(hashTable->data);1

  free(hashTable);

  return 0;

}

# ***\*2\**** ***\*B类（较难）\****

## ***\*2\*******\*.1\**** ***\*你选择的题目1\*******\*、\*******\*2、3、8\****

以下是关于暴力匹配和manacher求最大回文数的运行截图及其代码
暴力匹配：逐个字符向两边扩展以检查回文子串。时间复杂度为 O(n^2)。

Manacher：利用回文串对称性和中心扩展思想，以线性时间 O(n) 找到最长回文子串。
![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps9.jpg)

char s[18]="ATGCCTAGGTGAGTTAC";

//暴力匹配 

void force(){

​	int max_length=0;

​	char temp[17];	//用来接受最大的回文数

​	int i,j,x;

​	for(i=3;i<17;i++){	//第一层循环控制 用于判断的个数 

​		for(j=0;j<17-i;j++){		//控制开始的位置 

​			 int count =0;		

​			 for(x=0;x<i/2;x++){	//控制回文判断次数，3个回文数判断一次			 

​				 if(s[j+x]==s[j+i-x-1]){	

​			 	count++;

​				 }

​				 if (count == i / 2) {

​          if (i > max_length) {

​            max_length = i;

​            strncpy(temp, s + j, i);

​            temp[i] = '\0';

​          }

​        }

​			 }

​		}

​	}

​	printf("最长的回文数是:%s",temp);	

}

//manacher算法

void manacher(char *s, int n) {

  int len = 2 * n + 1;

  char t[len]; // 插入特殊字符后的字符串

  int P[len]; // 回文半径数组

  int maxRight = 0; // 已知回文串的最右边界

  int center = 0; // 对应的中心

  int maxLen = 0; // 最长回文串长度

  int start = 0; // 最长回文串的起始位置

  // 插入特殊字符

  t[0] = '#';

  for (int i = 0; i < n; i++) {

​    t[2 * i + 1] = s[i];

​    t[2 * i + 2] = '#';

  }

  for (int i = 0; i < len; i++) {

​    int mirror = 2 * center - i; // i 关于 center 的对称位置

​    if (i < maxRight) {

​      P[i] = (maxRight - i < P[mirror]) ? maxRight - i : P[mirror];

​    } else {

​      P[i] = 0;

​    }

​    // 向两边扩展

​    while (i - P[i] - 1 >= 0 && i + P[i] + 1 < len && t[i - P[i] - 1] == t[i + P[i] + 1]) {

​      P[i]++;

​    }

​    // 更新 maxRight 和 center

​    if (i + P[i] > maxRight) {

​      maxRight = i + P[i];

​      center = i;

​    }

​    // 记录最长回文串的信息

​    if (P[i] > maxLen) {

​      maxLen = P[i];

​      start = (i - P[i]) / 2;

​    }

  }

  // 输出最长回文串

  printf("最长回文串是：");

  for (int i = start; i < start + maxLen; i++) {

​    printf("%c", s[i]);

  }

  printf("\n");

}

int main(){

​	printf("初始字符串为：%s\n",s);

​	int n=strlen(s);

​	manacher(s,n);

​	return 0;

}	

## ***\*2\*******\*.2\**** ***\*你选择的题目2\****

 

注意在此处表明你选择的题目涉及到的章节。

 

如，本节我选择的题目是2，3，4，分别涉及到栈，树，图等。

### ***\*2\*******\*.2.1\**** ***\*题目的解题思路\****

先对所有的边进行初始化为最大值，然后进行n-1次（n是结点数）遍历（松弛）；得出源点到各个节点的最短距离；

### ***\*2.2.2\**** ***\*题目的关键代码\****

\#include<stdio.h>

\#include<limits.h>	//INT_MAX最大最小值的头文件 

typedef struct Edge{

​	int a,b,weight; 

};

void BellmanFord(int V,int E,Edge edge[],int src){

​	int dist[V];

​	//初始化无穷大

​	for(int i=0;i<V;i++){

​		dist[i]=INT_MAX;

​	}

​	dist[src-1]=0;	//src源点到自身的距离是0

​	for(int i=0;i<V-1;i++){

​		for(int j=0;j<E;j++){

​			int a=edge[j].a-1;		//只有1 2 3 4 5 的边  没有0边 所以要-1 

​			int b=edge[j].b-1;

​			int weight=edge[j].weight;

​			if(dist[a]!=INT_MAX&&dist[a]+weight<dist[b])

​				dist[b]=dist[a]+weight;

​		}

​	}

​	for(int i=0;i<V;i++){

​		if(dist[i]!=INT_MAX){

​			printf("%d\n",dist[i]);

​		}else{

​			printf("INS\n");

​		}

​	}

} 

### ***\*2\*******\*.2.4\**** ***\*程序的运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps10.jpg) 

 

## ***\*2.3.1 迷宫思路\****

\1. 递归算法思路：

从起点开始，向四个方向（上下左右）探索，检查是否可以移动到相邻的位置。递归调用函数，对于每一个可以移动到的相邻位置，计算从该位置到达目的地的最短路径长度。

  标记已经访问过的位置，避免重复访问，同时使用回溯进行路径搜索。 返回从当前位置到目的地的最小路径长度。

 

\2. BFS

使用队列来实现BFS，从起点开始，将起点入队。

不断从队列中取出一个节点，并检查其四个方向的相邻位置，将未访问过的可行位置入队，并标记为已访问。

当遇到终点时，即找到了从起点到终点的最短路径。

返回找到的最短路径的长度。

 

2.3 关键代码

 



// 初始化队列

void initQueue(Queue *q) {

  q->front = q->rear = 0;

}

// 判断队列是否为空

int isEmpty(Queue *q) {

  return q->front == q->rear;

}

// 入队

void enqueue(Queue *q, Point p) {

  q->queue[q->rear++] = p;

}

// 出队

Point dequeue(Queue *q) {

  return q->queue[q->front++];

}

// 检查坐标是否在迷宫内且可行走

int isValid(int x, int y) {

  return x >= 1 && x <= N && y >= 1 && y <= M && maze[x][y] == 0 && !visited[x][y];

}

// 递归算法求最短路径

int Digui(int x, int y, int destX, int destY) {

  if (x == destX && y == destY) return 0; // 如果当前位置是目的地，则路径长度为0（已到达目的地）

  visited[x][y] = 1; // 标记当前位置为已访问

  int minPath = 1e9; // 初始设置一个很大的值作为初始最小路径长度

  // 上下左右四个方向

  int dx[] = {-1, 1, 0, 0};

  int dy[] = {0, 0, -1, 1};

 

  for (int i = 0; i < 4; ++i) {

​    int newX = x + dx[i];

​    int newY = y + dy[i];

 

​    if (isValid(newX, newY)) { // 检查新坐标是否在迷宫内且可行走

​      int currentPath = Digui(newX, newY, destX, destY); // 递归调用，求解从新坐标到目的地的最短路径

​      minPath = min(minPath, currentPath + 1); // 更新最小路径长度

​    }

  }

  visited[x][y] = 0; // 回溯，重置当前位置的访问状态

  return minPath; // 返回最小路径长度

}

 

// BFS算法求最短路径

int BFS(Point start, Point dest) {

  Queue q;

  initQueue(&q); // 初始化队列q

  enqueue(&q, start); // 将起点入队

  visited[start.x][start.y] = 1; // 标记起点为已访问

 

  int dx[] = {-1, 1, 0, 0};

  int dy[] = {0, 0, -1, 1};

 

  while (!isEmpty(&q)) {		 // 当队列不为空时执行循环

​    Point current = dequeue(&q); // 出队一个点

 

​    if (current.x == dest.x && current.y == dest.y) {

​      return visited[current.x][current.y] - 1; // 如果当前点为目的地，则返回到达该点的最小路径长度

​    }

​    

​    for (int i = 0; i < 4; ++i) {

​      int newX = current.x + dx[i];

​      int newY = current.y + dy[i];

 

​      if (isValid(newX, newY)) { // 检查新坐标是否在迷宫内且可行走

​        visited[newX][newY] = visited[current.x][current.y] + 1; // 更新新坐标的访问值

​        Point next = {newX, newY};

​        enqueue(&q, next); // 将新坐标入队

​      }

​    }

  }

  return -1; // 若无法到达终点，则返回-1

}



### ***\*2.3.3运行截图\*******\* \****![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps11.jpg)

### ***\*2.4八皇后解题思路\**** 

主要是通过is_place函数来检查当前列是否可以放置皇后，如果列、对角线1、对角线2都未被占用，则返回1，代表可以放置皇后；否则返回0，代表当前列不能放置皇后。

 

定义回溯函数backtrack，以行为参数，从第0行开始搜索。如果已经搜索到第N行，代表找到一组解，将其打印出来并返回；否则，从第0列开始依次检查每一列是否可以放置皇后。如果可以放置，则将该皇后信息入栈，并继续搜索下一行；如果不可以放置，则继续检查下一列。如果所有列都检查完毕仍然无法放置皇后，则回溯到上一步，将该皇后信息出栈。

### ***\*主要代码\**** 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps12.jpg) 

### ***\*2.8.1强连通图思路\****

1、定义一个表示图的数据结构，使用来表示边的连接关系。

2、初始化图的矩阵，将所有边的连接状态初始化为0。

3、选择一个起始节点，调用 `isConnected` 函数判断从该节点开始是否可以访问到其他所有节点。

isConnected：

1、创建一个标记数组 `visited`，用于记录节点的访问状态，。

2、从给定节点开始进行深度优先搜索遍历，递归访问与当前节点相邻的未被访问节点，并将其标记为已访问状态。

3、检查是否有未被访问的节点，如果所有节点都被访问到，则返回强连通图；否则返回非强连通图。

### ***\*2.8.2关键代码\****



typedef struct {

  int edges[MAX_SIZE][MAX_SIZE]; // 存储边的矩阵

  int numVs; // 图中节点的数目

} Graph;

// 初始化有向图

void initGraph(Graph* graph) {

  // 初始化所有边为 0

  for (int i = 0; i < MAX_SIZE; i++) {

​    for (int j = 0; j < MAX_SIZE; j++) {

​      graph->edges[i][j] = 0;

​    }

  }

  graph->numVs = MAX_SIZE;

}

// 添加边

void addEdge(Graph* graph, int startx, int endVertex) {

  graph->edges[startx][endVertex] = 1;

}

// 深度优先搜索遍历

void DFS(Graph* graph, int v, int visited[]) {

  visited[v] = 1; // 标记节点为已访问状态

  // 递归遍历与当前节点相邻的未被访问节点

  for (int i = 0; i < graph->numVs; i++) {

​    if (graph->edges[v][i] && !visited[i]) {

​      DFS(graph, i, visited);

​    }

  }

}

// 判断从给定节点开始，是否可以访问到所有其他节点

int isConnected(Graph* graph, int v) {

  int visited[MAX_SIZE] = {0}; // 初始化所有节点为未访问状态

  DFS(graph, v, visited);

  // 检查是否有未被访问的节点

  for (int i = 0; i < MAX_SIZE; i++) {

​    if (!visited[i]) {

​      return 0; // 存在未访问节点，返回非强连通图

​    }

  }

  // 重新初始化 visited 数组为未访问状态

  for (int i = 0; i < MAX_SIZE; i++) {

​    visited[i] = 0;

  }

  // 反向深度优先搜索遍历

  DFS(graph, v, visited);

  // 检查是否有未被访问的节点

  for (int i = 0; i < MAX_SIZE; i++) {

​    if (!visited[i]) {

​      return 0; // 存在未访问节点，返回非强连通图

​    }

  }

  return 1; // 所有节点都被访问到，是强连通图

}

int main() {

  Graph graph;

  initGraph(&graph);

  // 添加边

  addEdge(&graph, 0, 1);

  addEdge(&graph, 0, 4);

  addEdge(&graph, 1, 3);

  addEdge(&graph, 2, 1);

  addEdge(&graph, 2, 4);

  addEdge(&graph, 3, 0);

  addEdge(&graph, 3, 2);

  addEdge(&graph, 4, 2);

  // 选择一个节点进行判断

  int startx = 0;

  // 判断是否为强连通图

  int result = isConnected(&graph, startx);

**
**

### ***\*2.8.3运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps13.jpg) 

### ***\*3\**** ***\*C类题目\****

### ***\*C13:找硬币思路\****

三个while循环分别从25、5、1依次排列下来，主要代码如下：

  while (sum >= 25) {

​    sum -= 25;

​    k++;

  }

  while (sum >= 5) {

​    sum -= 5;

​    b++;

  }

  while (sum >= 1) {

​    sum -= 1;

​    c++;

}

### ***\*C13:运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps14.jpg) 

 

### ***\*C14摆动序列 主要思路\****

遍历数组： 从数组的第二个元素开始遍历到倒数第二个元素。如果输入数组长度小于等于2，直接返回0

寻找不同的元素： 跳过连续相同的元素，找到不同的元素。

检查摆动条件： 检查当前元素与相邻元素的大小关系，如果不满足摆动条件，增加计数。

返回计数结果： 返回计数结果。

### ***\*主要代码\****



\##include <stdio.h>

 

int find(int arr[], int n) {

  if (n <= 1) {

​    return 0;

  }

  int count = 1; // 初始假设第一个元素为摆动序列的一个元素

  int direction = 0; // 0 表示未确定方向，1表示上升，-1表示下降

  for (int i = 1; i < n; i++) {

​    if (arr[i] > arr[i - 1] && (direction == 0 || direction == -1)) {

​      direction = 1; // 上升

​      count++; // 符合摆动条件，增加计数

​    } else if (arr[i] < arr[i - 1] && (direction == 0 || direction == 1)) {

​      direction = -1; // 下降

​      count++; // 符合摆动条件，增加计数

​    }

  }

 

  return n - count; // 需要删除的元素个数为总长度减去摆动序列的长度

}

int main() {

  int arr[20];

  int n = 0;

  printf("请输入数字序列，以空格间隔，输入其他字符结束\n");

  while (n < 20 && scanf("%d", &arr[n]) == 1) {

​    n++;

  }

  int del = find(arr, n);

  if (del == 0) {

​    printf("是摆动序列\n");

  } else {

​    printf("不是摆动序列，需要删除 %d 个元素\n", del);

  }

  return 0;

}



 

### ***\*运行截图\*******\* \****![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps15.jpg)

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps16.jpg) 

 

 

### ***\*C15子序列思路\****

1、创建双向链表，并且将A和B一个个输入

2、主要的是这里的decide函数用递归来判断A是否是B的子序列

### ***\*主要代码\****



typedef struct Node {

  int data;

  struct Node *next;

  struct Node *pre;

} Node;

 

// 创建新节点

Node* createNode(int data) {

  Node* newNode = (Node*)malloc(sizeof(Node));

  newNode->data = data;

  newNode->next = NULL;

  newNode->pre = NULL;

  return newNode;

}

 

// 尾插法

Node* insert(Node* head, Node* tail, int data) {

  Node* newNode = createNode(data);

  if (head == NULL) {

​    head = newNode;

​    tail = newNode;

  } else {

​    tail->next = newNode;

​    newNode->pre = tail;

​    tail = newNode;

  }

  return tail;

}

 

// 判断 B 是否是 A 的子序列

int decide(Node* A, Node* B) {

  if (A == NULL && B == NULL) {

​    return 1; // 空链表视为子序列

  }

  if (A == NULL || B == NULL) {

​    return 0; // A 为空但 B 不为空，或者 B 为空但 A 不为空，则不是子序列

  }

  if (A->data == B->data) {

​    return decide(A->next, B->next); // 递归判断下一个节点

  }

  return decide(A->next, B); // 继续在 A 中寻找与 B 第一个节点相同的节点

}

 

// 输出链表元素

void printList(Node* head) {

  Node* temp = head;

  while (temp != NULL) {

​    printf("%d ", temp->data);

​    temp = temp->next;

  }

  printf("\n");

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps17.jpg) 

 

### ***\*C17约瑟夫环 解题思路\**** 

本题是利用尾插法构建循环链表，然后用多层循环嵌套来处理约瑟夫环问题

主要算法：

约瑟夫环是一个数学和计算机科学问题，其中有n个人编号为1到n，围成一个圈，从第一个人开始报数，报到m的人出列，然后从出列的人的下一个人开始重新报数，直到所有人出列为止。该问题的主要算法步骤如下：

 

 

1、模拟报数并淘汰：从第一个人开始报数，每数到第m个人就将其淘汰（从圈中移除），直至所有人都被淘汰。这个过程循环执行，直到只剩下一个人为止。

2、移除被淘汰的人：当数到第m个人时，将其从链表或数组中移除。

3、重新报数：从被淘汰的人的下一个人开始重新报数，继续执行报数和淘汰步骤，直到所有人都被淘汰。

 

### ***\*主要代码\**** 



typedef struct Node {

​	int data;

​	struct Node* next;

} Node;

 

Node* init() {

​	Node* L = (Node*)malloc(sizeof(Node));

​	L->data = 0;

​	L->next = L;

​	return L;

}

 

Node* tailinsert(Node* L) {

​	int n;

​	Node* node, * temp;

​	printf("请输入数字，以空格间隔，输入#结束\n");

​	while (scanf("%d", &n) == 1) {

​		node = (Node*)malloc(sizeof(Node));

​		node->data = n;

 

​		temp = L;

​		while (temp->next != L) {

​			temp = temp->next;

​		}

​		temp->next = node;

​		node->next = L;

​		L->data++;

​	}

​	return L;

}

 

void Print(Node* p) {

​	Node* start = p;

​	do {

​		printf("%d ", p->data);

​		p = p->next;

​	} while (p != start);

​	printf("\n");

}

 

void ysf(Node* L, int sum, int step) {	//约瑟夫环 

​	Node* temp = L;

​	while (temp->next != temp) {

​		for (int i = 1; i < step; i++) {

​			temp = temp->next;

​		}

​		Node* delNode = temp->next;

​		printf("被淘汰的人的顺序: %d\n", delNode->data);

​		temp->next = delNode->next;		//将被淘汰的节点删除 

​		free(delNode);

​		temp = temp->next;

​	}

​	printf("最后剩下的人: %d\n", temp->data);

}

**
**

### ***\*运行截图\****

### ![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps18.jpg)***\* \*******\*C18交集并集思路\****

这个题需要用双向链表来建立链表，对输入的集合A和集合B分别进行处理；实际上也单向链表就足够处理该题。

对于输出并集：
可以对录入的集合B直接打印，然后在从A中找出B中不同的元素，再输出，同时对于相同的元素，记录到一个数组里面，再另外输出，这就是交集

时间复杂度主要取决于集合 A 和集合 B 的元素个数，大致可以表示为 O(n * m)，其中 n 和 m 分别是集合 A 和集合 B 的元素个数。

###  

### ***\*主要代码\**** 



typedef struct Node{

​	int data;

​	struct Node *next,*prior;	

}Node;

 

Node *creat(Node *L){

​	Node *r,*s;

​	char c;

​	L=(Node*)malloc(sizeof(Node));

​	r=L;

​	while(scanf("%d%c", &r->data, &c) == 2) {

​		s=(Node*)malloc(sizeof(Node));

​		s->prior = r;

​		r->next = s;

​		r=s;

 

​		if(c == '#') {

​			break;

​		}

​	}

​	r->next = NULL;

​	return L;

}

 

void jihe(Node *LA, Node* LB){

​	Node *la,*lb;

​	int i=0,temp[1000],f=-1;

​	la=LA;

​	lb=LB;

​	printf("并集有如下：\n");

​	

​	while(lb->next!=NULL){

​		printf("%d ",lb->data);

​		lb = lb->next;

​	} 

 

​	lb = LB;

​	while(la->next!=NULL){

​		while(lb->next!=NULL){

​			if(la->data==lb->data)

​				f=1;

​			lb = lb->next;

​		}

​		if(f==1){

​			temp[i]=la->data;

​			i++;

​		}else{				

​			printf("%d ",la->data);

​		}

​		la=la->next;

​		f=-1;

​		lb = LB;

​	}

​			printf("\n");

​	printf("交集如下\n");

​	for(int x=0;x<i;x++)

​		printf("%d ",temp[x]);

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps19.jpg) 

### ***\*C19奇偶链表拆分 解题思路\**** 

本题主要是先构建单链表存储原始数据，再对奇数偶数分别进行处理，奇数直接输出，偶数在存入数组中（也可以构建新链表），等遍历完原始链表之后，奇数就输出完了，再重新输出偶数数组

### ***\*主要代码\**** 



Node *creat1(){//创建原链表

​	int n;

​	Node *p,*head=NULL,*tail=NULL;

​	printf("请输入基础链表的元素，以空格间隔开，输入#结束\n"); 

​	while(scanf("%d",&n)==	1){

​		p=(Node *)malloc(sizeof(Node));

​		p->data=n;

​		p->next=NULL; 	//设置末尾节点的next为空 

​		if(head==NULL)

​			head=p;

​		else

​				tail->next=p;	//尾部节点的下一个节点更新为新节点 

​				tail=p;	

​			

​					//将新节点 置为尾部节点 

​	}

​	return head;

}

void *creat2(Node *p){//创建奇数偶数链表 

​	int arr[100];

​	int i=0;

​	printf("L1=");

​	while(p->next!=NULL){

​		if((p->data)%2==0){

​			arr[i]=p->data;	//偶数存入数组 

​			i++;

​	}else{

​		printf("%d->",p->data);

​	}

​	p=p->next;

}

​	printf("\nL2=");

​	for(int x=0;x<i;x++){

​		printf("%d->",arr[x]);

​	}

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps20.jpg) 

### ***\*C20中位数主要思路\****

分别输入两组数据并进行处理，合并之后再从小到大排序，取中间值，如果是奇数就直接使出，偶数就取平均值

### ***\*主要代码\**** 



\#include <stdio.h>

\#define MAX_SIZE 100

double median(int *arr1, int size1, int *arr2, int size2) {

  int totalSize = size1 + size2;

  int merged[MAX_SIZE];

  int i = 0, j = 0, k = 0;

  while (i < size1 && j < size2) {

​    if (arr1[i] <= arr2[j]) {

​      merged[k++] = arr1[i++];

​    } else {

​      merged[k++] = arr2[j++];

​    }

  }

  while (i < size1) {

​    merged[k++] = arr1[i++];

  }

  while (j < size2) {

​    merged[k++] = arr2[j++];

  }

  if (totalSize % 2 == 0) {

​    return (merged[totalSize / 2 - 1] + merged[totalSize / 2]) / 2.0;

  } else {

​    return merged[totalSize / 2];

  }

}

int main() {

  int arrA[MAX_SIZE], arrB[MAX_SIZE];

  int num, i = 0;

  char ch;

  printf("请输入数字序列（用空格分隔两个数组，以 # 分隔）: \n");

  while (scanf("%d%c", &num, &ch) == 2) {

​    if (ch == '#') {

​      arrA[i] = num;

​      break;

​    }

​    arrA[i++] = num;

  }

  i = 0; // 重置索引，开始读取第二个数组

  while (scanf("%d", &num) == 1) {

​    arrB[i++] = num;

  }

  double result = median(arrA, 5, arrB, 5);

  printf("两个数组的中位数为: %.1f\n", result);

  return 0;

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps21.jpg) 

 

### ***\*C22合法栈序列\**** 

### ***\*主要思路\**** 

\1. 遍历给定的出栈序列中的每个字符。

\2. 对于每个字符，判断其在特定字符集（abcde）中的位置。

\3. 如果当前字符不在字符集中，或者栈不为空且栈顶元素与当前字符不匹配，则将字符依次入栈，直到栈顶元素与当前字符匹配或栈为空。

\4. 如果栈顶元素与当前字符匹配，则将栈顶元素出栈。

\5. 最终，如果栈为空，则表示给定的出栈序列是由特定字符集通过栈操作能够生成的合法出栈序列，否则不合法。

### ***\*主要代码\**** 

 



// 函数：判断给定的出栈序列是否合法

bool isright(char *sequence) {

  int len = strlen(sequence);

  int stack[MAX_SIZE]; // 模拟栈

  int top = -1; // 栈顶指针

 

  int i, j = 0;

  for (i = 0; i < len; ++i) {

​    char ch = sequence[i];

 

​    // 找到出栈序列中字符在字符集中的位置

​    int pos = -1;

​    const char charset[] = "abcde";

​    for (j = 0; j < strlen(charset); ++j) {

​      if (charset[j] == ch) {

​        pos = j;

​        break;

​      }

​    }

 

​    // 如果找不到字符或栈顶元素不等于当前字符，则将字符入栈

​    if (pos == -1 || (top != -1 && stack[top] != pos)) {

​      while (j < len && sequence[j] != charset[top + 1]) {

​        // 如果栈顶元素不等于当前字符，则继续将字符入栈

​        if (top >= MAX_SIZE - 1) {

​          return false; // 栈已满，出错

​        }

​        stack[++top] = charset[++j];

​      }

​    } else { // 栈顶元素等于当前字符，出栈

​      top--;

​    }

  }

 

  // 如果栈为空，则出栈序列合法

  return top == -1;

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps22.jpg) 

### ***\*C23 进制转换思路\****

### ***\*思路如下：\****

\1. 定义一个栈结构以及栈操作的基本函数（如初始化、判断栈是否为空、入栈、出栈等）。

\2. 编写将十进制数转换为二进制、八进制和十六进制的函数。对于每种进制的转换，使用不同的算法（例如递归或迭代）将对应的余数或模数依次压入栈中。

\3. 创建一个函数来打印栈中的元素，以显示转换后的结果。在输出时处理输入为 0 的情况。

###  

###  

### ***\*主要代码\**** 



\#define MAX 100

 

typedef struct {

  int top;

  int item[MAX];

} Stack;

 

void init(Stack *stack) {

  stack->top = -1;

}

 

bool isFULL(Stack *stack) {

  return stack->top == MAX - 1;

}

 

bool isNULL(Stack *stack) {

  return stack->top == -1;

}

 

void push(Stack *stack, int data) {

  if (!isFULL(stack)) {

​    stack->item[++stack->top] = data;

  }

}

 

int pop(Stack *stack) {

  if (!isNULL(stack)) {

​    return stack->item[stack->top--];

  }

  return -1;  // 返回-1表示栈为空

}

 

void Ten_two(Stack *stack, int num) {

  if (num == 0) {

​    push(stack, 0);

​    return;

  }

 

  while (num > 0) {

​    push(stack, num % 2);

​    num /= 2;

  }

}

 

void Ten_sixteen(Stack *stack, int num) {

  if (num == 0) {

​    push(stack, 0);

​    return;

  }

 

  while (num > 0) {

​    int temp = num % 16;

​    if (temp < 10) {

​      push(stack, temp + '0');

​    } else {

​      push(stack, temp - 10 + 'A');

​    }

​    num /= 16;

  }

}

 

 

void Ten_eight(Stack *stack, int num) {

  if (num == 0) {

​    push(stack, 0);

​    return;

  }

 

  while (num > 0) {

​    push(stack, num % 8);

​    num /= 8;

  }

}

 

void Print(Stack *stack) {

  while (!isNULL(stack)) {

​    int num = pop(stack);

​    if (num >= 65) {

​      printf("%c", num);

​    } else {

​      printf("%d", num);

​    }

  }

  printf("\n");

}

 

void clear(Stack *stack) {

  stack->top = -1;

}



 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps23.jpg)

### ***\*C24KMP算法 主要思路\****

 KMP 算法的主要思路是利用部分匹配表，它是子串自身的一个属性。这个表告诉我们，在发生不匹配时，可以跳过的字符数量。

算法的关键在于构建这个部分匹配表。它通过在子串内部寻找相同的前缀和后缀，记录匹配的长度，以此为基础优化匹配过程。

 

一旦我们得到了部分匹配表，就可以使用它来在目标串中搜索子串。在搜索过程中，当出现不匹配时，根据部分匹配表中的信息，移动子串，使其对齐部分已匹配的字符，而不是从头开始匹配。这样就能有效减少不必要的比较次数，提高匹配效率。

### ***\*主要代码\**** 



void LPSarry(char *pat, int M, int *lps) {

  int len = 0;

  int i = 1;

  lps[0] = 0;

 

  while (i < M) {

​    if (pat[i] == pat[len]) {

​      len++;

​      lps[i] = len;

​      i++;

​    } else {

​      if (len != 0) {

​        len = lps[len - 1];

​      } else {

​        lps[i] = 0;

​        i++;

​      }

​    }

  }

}

int KMPSearch(char *pat, char *txt) {

  int M = strlen(pat);

  int N = strlen(txt);

  int *lps = (int *)malloc(sizeof(int) * M);

  int j = 0;

 

  LPSarry(pat, M, lps);

 

  int i = 0;

  while (i < N) {

​    if (pat[j] == txt[i]) {

​      j++;

​      i++;

​    }

 

​    if (j == M) {

​      free(lps);

​      return i - j;

​    } else if (i < N && pat[j] != txt[i]) {

​      if (j != 0)

​        j = lps[j - 1];

​      else

​        i = i + 1;

​    }

  }

  free(lps);

  return -1;

}

**
**

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps24.jpg) 

### ***\*C25字符格式化主要思路\**** 

这个问题的主要思路是：

 

\1. 遍历输入的句子中的字符。

\2. 处理多余的空格：检测连续的空格，并只保留一个空格。

\3. 重建句子：逐字符将处理后的字符放入新的位置。

4.确保句子不以空格开头：如果句子开头有空格，将其删除。

 

### ***\*主要代码\**** 



void Found(char *sentence) {

  int len = strlen(sentence);

  bool spaceFound = false;

  // 记录处理后的索引位置

  int newIndex = 0;

  for (int i = 0; i < len; i++) {

​    if (sentence[i] == ' ') {

​      // 如果遇到空格，设置标志以便于处理多余空格

​      spaceFound = true;

​    } else {

​      // 如果当前字符不是空格

​      if (spaceFound) {

​        // 如果前面有空格，加一个空格并更新索引位置

​        sentence[newIndex++] = ' ';

​        spaceFound = false;

​      }

​      // 将当前字符放入处理后的字符串中

​      sentence[newIndex++] = sentence[i];

​    }

  }

 

  // 在新字符串末尾添加结束符

  sentence[newIndex] = '\0';

}

 

int main() {

  char sentence[1000];

  printf("请输入一个句子：");

  fgets(sentence, sizeof(sentence), stdin);

  // 格式化句子

  Found(sentence);

  printf("格式化后的句子为：%s\n", sentence);

 

  return 0;

}



 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps25.jpg) 

### ***\*C26稀疏矩阵的运算主要思路\**** 

### ***\*主要代码\**** 

### ***\*运行截图\****

### ***\*C27二叉树共同祖先主要思路\**** 

定义二叉树的结构体和节点结构体。对于顺序存储，我们可以使用数组来表示二叉树；对于二叉链存储，我们可以使用指针来表示节点之间的关系。

使用递归的方式实现这两种算法。递归的思路是：如果根节点等于其中一个节点或者根节点是其中一个节点的祖先，则根节点就是最近公共祖先；否则，在左子树和右子树中分别查找最近公共祖先。

### ***\*主要代码\**** 

\#include <stdio.h>

\#include <stdlib.h>

// 二叉树的节点结构体（二叉链存储）

typedef struct TreeNode {

  int data;          // 节点的值

  struct TreeNode* left;    // 左子节点指针

  struct TreeNode* right;   // 右子节点指针

} TreeNode;

// 通过顺序存储构建二叉树

TreeNode* buildBinaryTree(int* arr, int size, int index) {

  if (index >= size)

​    return NULL;

  TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));

  root->data = arr[index];

  root->left = buildBinaryTree(arr, size, 2 * index + 1);

  root->right = buildBinaryTree(arr, size, 2 * index + 2);

  return root;

}

// 在二叉树中查找最近公共祖先（顺序存储）

int Find(int* arr, int size, int i, int j) {

  if (i >= size || j >= size)

​    return -1;

 

  // 根节点下标

  int rootIndex = 0;

 

  // 查找最近公共祖先

  while (rootIndex < size) {

​    if ((arr[rootIndex] == arr[i] || arr[rootIndex] == arr[j]) ||

​      (arr[i] < arr[rootIndex] && arr[j] > arr[rootIndex]) ||

​      (arr[i] > arr[rootIndex] && arr[j] < arr[rootIndex])) {

​      // 如果根节点等于其中一个节点，或者根节点在两个节点之间，则返回根节点

​      return arr[rootIndex];

​    }

​    else if (arr[i] < arr[rootIndex] && arr[j] < arr[rootIndex]) {

​      // 如果两个节点都小于根节点，则继续在左子树中查找

​      rootIndex = 2 * rootIndex + 1;

​    }

​    else if (arr[i] > arr[rootIndex] && arr[j] > arr[rootIndex]) {

​      // 如果两个节点都大于根节点，则继续在右子树中查找

​      rootIndex = 2 * rootIndex + 2;

​    }

​    else {

​      // 如果一个节点小于根节点，一个节点大于根节点，则返回根节点

​      return arr[rootIndex];

​    }

  }

 

  return -1;

}

// 在二叉树中查找最近公共祖先（二叉链存储）

TreeNode* Findlink(TreeNode* root, int i, int j) {

  if (root == NULL)

​    return NULL;

  if (root->data == i || root->data == j)

​    return root;

 

  TreeNode* left = Findlink(root->left, i, j);

  TreeNode* right = Findlink(root->right, i, j);

 

  if (left != NULL && right != NULL)

​    return root;

  else if (left != NULL)

​    return left;

  else if (right != NULL)

​    return right;

 

  return NULL;

}

 

int main() {

  // 使用顺序存储构建二叉树

  int seqTree[] = { 6, 2, 8, 0, 4, 7, 9, 3, 5 };

  int size = sizeof(seqTree) / sizeof(seqTree[0]);

  // 指定节点 i 和 j

  int i = 3;

  int j = 5;

  // 在顺序存储的二叉树中查找最近公共祖先

  int ancestorSeq = Find(seqTree, size, i, j);

  printf("顺序存储：最近公共祖先编号：%d，值：%d\n", ancestorSeq, seqTree[ancestorSeq]);

 

  // 使用二叉链存储构建二叉树

  TreeNode* linkTree = buildBinaryTree(seqTree, size, 0);

 

  // 在二叉链存储的二叉树中查找最近公共祖先

  TreeNode* ancestorLink = Findlink(linkTree, i, j);

  printf("二叉链存储：最近公共祖先编号：%d，值：%d\n",ancestorLink->data, ancestorLink->data);

 

  return 0;

}

 

### ***\*运行截图及其测试案例\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps26.jpg) 

### ***\*C28二叉树类型主要思路\**** 

检查给定的二叉树是否为满二叉树的函数 `isFull`，通过计算左子树和右子树的高度是否相等来判断二叉树是否为满二叉树。

检查给定的二叉树是否为完全二叉树的函数 `isComplete`，使用队列进行层次遍历，检查空节点的位置是否合法来判断二叉树是否为完全二叉树。

### ***\*主要代码\**** 

\#include <stdio.h>

\#include <stdlib.h>

 

// 定义二叉树节点结构

typedef struct TreeNode {

  int data;

  struct TreeNode* left;

  struct TreeNode* right;

} TreeNode;

 

// 创建新节点

TreeNode* createNode(int data) {

  TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));

  if (newNode == NULL) {

​    printf("内存分配失败\n");

​    exit(1);

  }

  newNode->data = data;

  newNode->left = NULL;

  newNode->right = NULL;

  return newNode;

}

 

// 判断二叉树是否为满二叉树

int isFULL(TreeNode* root) {

  if (root == NULL)

​    return 1;

  

  int leftHeight = 0, rightHeight = 0;

  TreeNode* temp = root;

 

  // 计算左子树高度

  while (temp != NULL) {

​    leftHeight++;

​    temp = temp->left;

  }

 

  temp = root;

 

  // 计算右子树高度

  while (temp != NULL) {

​    rightHeight++;

​    temp = temp->right;

  }

 

  // 如果左右子树高度相等，则为满二叉树

  if (leftHeight == rightHeight)

​    return 1;

  else

​    return 0;

}

 

// 判断二叉树是否为完全二叉树

int isComplete(TreeNode* root) {

  if (root == NULL)

​    return 1;

  

  int flag = 0;  // 标记是否遇到空节点

  TreeNode* queue[100];  // 队列存储节点

  int front = -1, rear = -1;

  queue[++rear] = root;

 

  while (rear != front) {

​    TreeNode* current = queue[++front];

 

​    // 遇到空节点后，检查队列中剩余的节点是否为空节点

​    if (current == NULL) {

​      flag = 1;

​    } else {

​      // 如果已经遇到了空节点，说明不是完全二叉树

​      if (flag == 1)

​        return 0;

​      

​      // 将左右子节点入队

​      queue[++rear] = current->left;

​      queue[++rear] = current->right;

​    }

  }

 

  return 1;

}

 

int main() {

  TreeNode* root = NULL;

  int data;

 

  // 从键盘输入节点数据，以-1表示输入结束

  printf("请输入二叉树节点数据（以-1结束）：\n");

  while (1) {

​    scanf("%d", &data);

​    if (data == -1)

​      break;

​    

​    TreeNode* newNode = createNode(data);

 

​    if (root == NULL) {

​      root = newNode;

​    } else {

​      // 从根节点开始依次比较，插入到合适的位置

​      TreeNode* current = root;

​      TreeNode* parent;

 

​      while (1) {

​        parent = current;

​        if (data < current->data) {

​          current = current->left;

​          if (current == NULL) {

​            parent->left = newNode;

​            break;

​          }

​        } else {

​          current = current->right;

​          if (current == NULL) {

​            parent->right = newNode;

​            break;

​          }

​        }

​      }

​    }

  }

 

  // 判断二叉树类型并输出结果

  if (isFULL(root))

​    printf("该二叉树是满二叉树\n");

  else

​    printf("该二叉树不是满二叉树\n");

 

  if (isComplete(root))

​    printf("该二叉树是完全二叉树\n");

  else

​    printf("该二叉树不是完全二叉树\n");

  return 0;

}

 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps27.jpg) 

### ***\*C31\*******\*二叉树路径输出\**** ***\*主要思路\**** 

### ***\*关键代码\**** 

\#include <stdio.h>

\#include <stdlib.h>

// 定义二叉树节点结构

typedef struct TreeNode {

  char data;

  struct TreeNode* left;

  struct TreeNode* right;

} TreeNode;

 

// 创建新节点

TreeNode* createNode(char data) {

  TreeNode* newNode = (TreeNode*)malloc(sizeof(TreeNode));

  if (newNode == NULL) {

​    printf("内存分配失败\n");

​    exit(1);

  }

  newNode->data = data;

  newNode->left = NULL;

  newNode->right = NULL;

  return newNode;

}

 

 

// 辅助函数，递归遍历二叉树，并找到指定叶子节点

void printh(TreeNode* node, char leaf, int path[], int pathLen) {

  if (node == NULL) {

​    return;

  }

  // 将当前节点添加到路径中

  path[pathLen] = node->data;

  pathLen++;

  // 如果是叶子节点且值为所需的叶子节点，则输出路径

  if (node->left == NULL && node->right == NULL && node->data == leaf) {

​    printf("从根节点到叶子节点 '%c' 的路径为：", leaf);

​    for (int i = 0; i < pathLen; i++) {

​      printf("%c ", path[i]);

​    }

​    printf("\n");

  } else {

​    // 递归遍历左子树和右子树

​    printh(node->left, leaf, path, pathLen);

​    printh(node->right, leaf, path, pathLen);

  }

}

// 输出从根节点到叶子节点的路径

void Printpath(TreeNode* root, char leaf) {

  static int path[100];  // 存储路径

  int pathLen = 0;  // 路径长度

 

  printh(root, leaf, path, pathLen);

}

int main() {

  // 创建二叉树

  TreeNode* root = createNode('A');

  root->left = createNode('B');

  root->right = createNode('C');

  root->left->left = createNode('D');

  root->left->right = createNode('E');

  root->right->left = createNode('F');

  // 输出从根节点到叶子节点 'F' 的路径

  Printpath(root, 'F');

  return 0;

}

 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps28.jpg) 

### ***\*C38大数运算主要思路\**** 

这个简单的程序用于处理大数的加、减和乘法运算。以下是其主要思路：

 

\1. 加法：

  从个位开始逐位相加，同时考虑进位。

  使用字符数组模拟大数相加的过程。

\2. 减法：

  从个位开始逐位相减，同时考虑借位。

  使用字符数组模拟大数相减的过程。

3.乘法：

  采用乘法的竖式计算方法，按位相乘并将结果相加。

  使用字符数组模拟大数相乘的过程。

### ***\*主要代码\****

\#include <stdio.h>

\#include <string.h>

\#define MAX_DIGITS 1000

// 反转字符串函数

void reverseString(char str[]) {

  int len = strlen(str);

  int start = 0;

  int end = len - 1;

  while (start < end) {

​    char temp = str[start];

​    str[start] = str[end];

​    str[end] = temp;

​    start++;

​    end--;

  }

}

// 实现大数加法

void Jia(char num1[], char num2[], char result[]) {

  int carry = 0;

  int len1 = strlen(num1);

  int len2 = strlen(num2);

  int i = 0;

 

  // 从最低位开始逐位相加，同时考虑进位

  while (i < len1 || i < len2 || carry != 0) {

​    int digit1 = (i < len1) ? (num1[i] - '0') : 0;

​    int digit2 = (i < len2) ? (num2[i] - '0') : 0;

​    int sum = digit1 + digit2 + carry;

 

​    result[i] = (sum % 10) + '0'; // 将个位数字转换为字符并存储在结果中

​    carry = sum / 10; // 计算进位

​    i++;

  }

 

  result[i] = '\0'; // 字符串结尾

  reverseString(result); // 反转结果，得到正确的数字顺序

}

// 实现大数减法

void Jian(char num1[], char num2[], char result[]) {

  int len1 = strlen(num1);

  int len2 = strlen(num2);

  int borrow = 0;

  int i = 0;

  // 从最低位开始逐位相减，同时考虑借位

  while (i < len1 || i < len2) {

​    int digit1 = (i < len1) ? (num1[i] - '0') : 0;

​    int digit2 = (i < len2) ? (num2[i] - '0') : 0;

​    int diff = digit1 - digit2 - borrow;

​    if (diff < 0) {

​      diff += 10;

​      borrow = 1;

​    } else {

​      borrow = 0;

​    }

​    result[i] = diff + '0'; // 将差值转换为字符并存储在结果中

​    i++;

  }

  result[i] = '\0'; // 字符串结尾

  reverseString(result); // 反转结果，得到正确的数字顺序

}

 

// 实现大数乘法

void And(char num1[], char num2[], char result[]) {

  int len1 = strlen(num1);

  int len2 = strlen(num2);

  int product[MAX_DIGITS] = {0};

  // 执行乘法操作，保存中间结果到数组中

  for (int i = len1 - 1; i >= 0; i--) {

​    for (int j = len2 - 1; j >= 0; j--) {

​      int digit1 = num1[i] - '0';

​      int digit2 = num2[j] - '0';

​      product[i + j + 1] += digit1 * digit2; // 计算乘积并加到对应位置

​    }

  }

  // 处理进位

  for (int i = len1 + len2 - 1; i > 0; i--) {

​    product[i - 1] += product[i] / 10;

​    product[i] %= 10;

  }

  int i = (product[0] != 0) ? 0 : 1;

  int j = 0;

  // 将结果转换为字符数组

  while (i < len1 + len2) {

​    result[j++] = product[i++] + '0';

  }

  result[j] = '\0'; // 字符串结尾

}

int main() {

  char num1[MAX_DIGITS], num2[MAX_DIGITS], result[MAX_DIGITS * 2]; // 可以存储较大的结果

  // 读取输入的两个大数

  printf("输入第一个大数: ");

  scanf("%s", num1);

  printf("输入第二个大数: ");

  scanf("%s", num2);

  // 调用函数进行加、减、乘运算并输出结果

  Jian(num1, num2, result);

  printf("加法结果: %s\n", result);

  Jian(num1, num2, result);

  printf("减法结果: %s\n", result);

  And(num1, num2, result);

  printf("乘法结果: %s\n", result);

  return 0;

}

 

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps29.jpg) 

### ***\*C41二叉树范围和主要思路\**** 

主要思路是通过递归遍历二叉搜索树，将符合范围条件的节点值累加到总和中。最后返回总和值。

### ***\*主要代码\**** 

\#include <stdio.h>

\#include <stdlib.h>

// 定义二叉树节点结构体

typedef struct TreeNode {

  int val;

  struct TreeNode *left;

  struct TreeNode *right;

} TreeNode;

// 递归遍历函数，计算范围内节点的总和

int rangeSumBST(TreeNode* root, int low, int high) {

  // 初始化总和为0

  int sum = 0;

  // 当前节点为空，返回0

  if (root == NULL) {

​    return sum;

  }

  // 当前节点值在范围内，则将其加入总和中

  if (root->val >= low && root->val <= high) {

​    sum += root->val;

  }

  // 当前节点值大于范围的最小值，遍历左子树

  if (root->val > low) {

​    sum += rangeSumBST(root->left, low, high);

  }

  // 当前节点值小于范围的最大值，遍历右子树

  if (root->val < high) {

​    sum += rangeSumBST(root->right, low, high);

  }

  return sum;

}

int main() {

  // 从键盘输入二叉搜索树和范围

  printf("请输入按照先序遍历输入的二叉搜索树:\n");

  TreeNode* root = (TreeNode*)malloc(sizeof(TreeNode));

  scanf("%d", &(root->val));

  root->left = NULL;

  root->right = NULL;

  char ch;

  ch = getchar();

  while (ch == ' ') {

​    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));

​    scanf("%d", &(node->val));

​    node->left = NULL;

​    node->right = NULL;

​    TreeNode* p = root;

​    while (1) {

​      if (node->val < p->val) {

​        if (p->left == NULL) {

​          p->left = node;

​          break;

​        } else {

​          p = p->left;

​        }

​      } else {

​        if (p->right == NULL) {

​          p->right = node;

​          break;

​        } else {

​          p = p->right;

​        }

​      }

​    }

​    ch = getchar();	//吃掉一个换行回车符

  }

  printf("请输入范围的最小值和最大值:");

  int low, high;

  scanf("%d%d", &low, &high);

  // 计算范围内节点的总和

  int sum = rangeSumBST(root, low, high);

  printf("范围 [%d, %d] 内节点的总和是 %d\n", low, high, sum);

  

  return 0;

}

### ***\*运行截图\****

![img](file:///C:\Users\欧阳家胜\AppData\Local\Temp\ksohtml33432\wps30.jpg) 



 